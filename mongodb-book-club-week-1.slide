# MongoDB Book Club ğŸ“•
Week 1: Chapters 1 & 2
6 Jan 2023
Tags: books, architecture, mongodb, databases
Summary: Week 1 of the FloQast MongoDB book club

Mark Thomas
Staff Software Engineer, FloQast
markt@floqast.com
https://ifelse.io
@markthethomas

## Welcome!

## Intro
- ğŸ‘‹ Hi, Iâ€™m Mark!
- ğŸ‘´ At FQ since 2016
- ğŸ‘·â€â™‚ï¸ Worked on Compliance, Autorec, Analytics/Dashboards, le monolith etc.
- âœ… Iâ€™m a Staff Software Engineer focused on Compliance (Rhea, Skoll, Tarvos, Ymir, &c)
- ğŸ’¾ Iâ€™m interested in product engineering, performance, front-end, software architecture, databases, and distributed systems
- ğŸ“† I hold office hours every Friday from 1-2pm PST - join if you want! Link in my slack profile or ask me for it

: take 30s at most for this slide

## Book Club Format / Resources ğŸ“•

- #mongodb-book-club channel in Slack
- **summary**
- **Q&A**
- **Breakouts**
- **Regroup** / **wrap / logistics**:

## Questions? ğŸ™‹â€â™€ï¸

## Why do a book club? Why now? ğŸ¤”
- Databases are hard
    - large, complex, distributed systems
    - can be hard to learn, always changing
    - databases vary widely in their capabilities
- Databases are important
    - critical to basically any app at FQ
    - **"Data is the new oil"**
    - FloQast wins when our engineers are great at database stuff
- MongoDB is crucial to FQ's future and success
    - rapidly scaling engineering teams 
    - the _most_ critical system we have (where the "oil" lives)

: take 1-2 min for this slide
: ask everyone to put their confidence in how they use mongoDB on a scale of 1-10 in the zoom chat

## Databases! ğŸ—„ï¸

## What even *is* a database? ğŸ¤“ 

They can't be that complicated, right? Right? ğŸ˜…ğŸ˜…ğŸ˜…

: this book is all about a database, so let's chat about that for a second
: maybe even better yet, we'll build one really quick to whet our appetite

## Let's build one! ğŸš§

: let's get thinking about databases, how they work, how we use them, how they're built, etc.
: let's build a simple database in 5 minutes or less

## Let's create 'JSONDB' ğŸ“€

.code ./code/mongodb-book-club-week-1/jsonDB-1.js

## Let's add persistence! ğŸ“

: let's create a simple database that stores JSON objects in memory
: it will have set, get, and delete methods

## This isn't so hard! ğŸ¤Œ

.code ./code/mongodb-book-club-week-1/jsonDB-2.js

: Let's make it a _real_ database and add persistence.

## this is getting harder! ğŸ˜…

Congrats. We can write JSON files ğŸ’ª 

Let's make it handle crashes and add a **WAL** (write-ahead log)

## Crash-resistant? ğŸ¤¯

Add a `.log` file we'll add entries to.

.code ./code/mongodb-book-club-week-1/jsonDB-3.js /START OMIT/,/END OMIT/

## Log time ğŸªµ

Append an entry to the log file when an action is taken. In JSON format, of course!

.code ./code/mongodb-book-club-week-1/jsonDB-3a.js /START OMIT/,/END OMIT/

: let's add a log method that will record entries during writes (sets and deletes)

## Don't forget to update our set / get / delete methods!

## Replay â®ï¸

Add the ability to read the log file.

.code ./code/mongodb-book-club-week-1/jsonDB-3b.js /START OMIT/,/END OMIT/

: get the file
: ensure the file is ordered properly by timestamp
: replay the log file to apply writes to the database
: truncate the log file and save the new state


## Let's try it out! ğŸš€

.video ./images/crash-recovery.webm video/webm _ 750

## That wasn't too bad! ğŸ¤ª

Now we just need to...
- add a network API so clients can send remote commands
- add a query langauge. SQL? Our own? 
- implement a more efficient storage engine
- add a way to scale it across multiple machines
- allow multiple clients to access it at the same time
- handle concurrency
- add client libraries for Node, Go, Python, Ruby, Java, etc.
- prove it works correctly at scale
- add a way to backup and restore the database
- write docs
- ... and more!

## databases are hard to build ğŸ˜…

We can stick with MongoDB. It deals with: 
- ensuring durable persistence on disk (no bad files, no data loss)
- fast reads and writes (no slow queries*)
- concurrency for reads, writes, backups, etc.
- indexes, aggregations, backups, etc.
- a query language and subsequent query planner & rewriter
- a network API
- a way to scale across multiple machines (replica sets, sharding)
- a way to handle multiple clients at the same time
- a suite of language drivers (mongodb-node.js, Mongoose, etc.)
- a way to prove it works correctly at scale ([jepsen testing](https://www.mongodb.com/jepsen))

Why learn this stuff? 

_The better you understand a system and how it works, the better you can use, opperate, and debug it._

## MongoDB ğŸ‘‹

## Hello, Mongo ğŸ¢
- For "huMONGOus" workloads
- Document-oriented database
- JSON-like documents
- Non-SQL query language
- Schema-less
- Distributed
- High availability
- Horizontal scalability

## MongoDB Philosophy ğŸ’­
- **Flexible**: schema-less*; (less) impedence mismatch (between your app and the db)
- **Performant**: fast reads and writes
- **Scalable**: horizontal scaling via sharding, replica sets
- **Reliable**: Replication, highly-available

*_everything_ has a schema in the end

## MongoDB Architecture Terms ğŸ—ï¸
- **Document**: JSON-ish object. Stored as BSON (binary JSON).
- **Collection**: a group of documents
- **Database**: a group of collections
- **Cluster**: a group of databases
- **Shard**: a group of servers that store a subset of a cluster's data
- **Replica Set**: a group of servers that store a copy of a cluster's data

## High-level Components ğŸ§±

.image /images/mongo-arch.png _ 800

## MongoDB vs. SQL ğŸ¤”

.image /images/mongo-vs-sql.png _ 1000

## Documents
- Keys in documents are strings
- Every document has an `_id` field (an ObjectID)
- 16 MB max size
- BSON (binary JSON) is the storage format at rest

## Collections
- A group of documents
- Usually one collection per "type" of document
- some restrictions on naming, length

## Databases
- collections of ... collections
- usually one database per application
- can have multiple databases per cluster

## Data Types
- **ObjectID**: 12-byte ID value (4-byte timestamp, 3-byte machine ID, 2-byte process ID, 3-byte counter)
- **Null**: null (the value) or a non-existent field
- **Boolean**: true, false
- **Numbers**: 64-bit float, NumberInt, NumberLong
- **Decimal128**: 128-bit decimal; ~great for money!~ just use ints
- **String**: UTF-8 string
- **Array**: Useful for lists, sets. Can contain other primitive types.
- **Embedded Documents**: Other documents can be arbitrarily nested
- **Date**: 64-bit integer, ms since epoch. No TZ
- **Binary Data**: new BinData()
- **Regular Expression**: new RegExp()
- **Code**: arbitrary JS code

## ObjectIDs
- 12-byte ID value (4-byte timestamp, 3-byte machine ID, 2-byte process ID, 3-byte counter)
- 4-byte timestamp is seconds since epoch
    - this means you can sort by `_id`! 
- Faster to generate than UUIDs or autoincrementing ints
- automatically created for a doc if `_id` is not specified

